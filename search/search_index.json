{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u26a1\ufe0f Circuit \u00b6 \ud83d\udea7 Under construction \ud83d\udea7 This project is very much a work in progress and far from finished! Overview \u00b6 Circuit is a simple, lightweight, and extensible framework for building Kotlin applications that\u2019s Compose from the ground up. Compose Runtime vs. Compose UI Compose itself is essentially two libraries \u2013 Compose Compiler and Compose UI. Most folks usually think of Compose UI, but the compiler (and associated runtime) are actually not specific to UI at all and offer powerful state management APIs. Jake Wharton has an excellent post about this: https://jakewharton.com/a-jetpack-compose-by-any-other-name/ It builds upon core principles we already know like Presenters and UDF, and adds native support in its framework for all the other requirements we set out for above. It\u2019s heavily influenced by Cash App\u2019s Broadway architecture ( talked about at Droidcon NYC , also very derived from our conversations with them). Circuit\u2019s core components are its Presenter and Ui interfaces. A Presenter and a Ui cannot directly access each other. They can only communicate through state and event emissions. UIs are compose-first. Presenters are also compose-first. They do not emit Compose UI, but they do use the Compose runtime to manage and emit state. Both Presenter and Ui each have a single composable function. In most cases, Circuit automatically connects presenters and UIs. Presenter and Ui are both generic types, with generics to define the UiState types they communicate with. They are keyed by Screen s. One runs a new Presenter / Ui pairing by requesting them with a given Screen that they understand. Circuits The pairing of a Presenter and Ui for a given Screen key is what we semantically call a \u201ccircuit\u201d. Your application is composed of \u201ccircuits\u201d. A simple counter Presenter + Ui pairing would be a \u201ccounter circuit\u201d. Nested presenter/UIs would be \u201cnested circuits\u201d or \u201csub circuits\u201d Composite presenter/UIs would be \u201ccomposite circuits\u201d etc etc. Circuit\u2019s repo ( https://github.com/slackhq/circuit ) is being actively developed in the open, which allows us to continue collaborating with external folks too. We have a trivial-but-not-too-trivial sample app that we have been developing in it to serve as a demo for a number of common patterns in Circuit use. Counter Example \u00b6 This is a very simple case of a Counter circuit that displays the count and has buttons to increment and decrement. There\u2019s some glue code missing from this example that\u2019s covered in the Code Gen (TODO link) section later. @Parcelize object CounterScreen : Screen { data class CounterState ( val count : Int , val eventSink : ( CounterEvent ) -> Unit , ) : CircuitUiState sealed interface CounterEvent : CircuitUiEvent { object Increment : CounterEvent object Decrement : CounterEvent } } @CircuitInject < CounterScreen > @Composable fun CounterPresenter (): CounterState { var count by rememberSaveable { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } @CircuitInject < CounterScreen > @Composable fun Counter ( state : CounterState ) { Box ( Modifier . fillMaxSize ()) { Column ( Modifier . align ( Alignment . Center )) { Text ( modifier = Modifier . align ( CenterHorizontally ), text = \"Count: ${ state . count } \" , style = MaterialTheme . typography . displayLarge ) Spacer ( modifier = Modifier . height ( 16. dp )) val eventSink = state . eventSink Button ( modifier = Modifier . align ( CenterHorizontally ), onClick = { eventSink ( CounterEvent . Increment ) } ) { Icon ( rememberVectorPainter ( Icons . Filled . Add ), \"Increment\" ) } Button ( modifier = Modifier . align ( CenterHorizontally ), onClick = { eventSink ( CounterEvent . Decrement ) } ) { Icon ( rememberVectorPainter ( Icons . Filled . Remove ), \"Decrement\" ) } } } } License \u00b6 Copyright 2022 Slack Technologies, LLC Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Introduction"},{"location":"#circuit","text":"\ud83d\udea7 Under construction \ud83d\udea7 This project is very much a work in progress and far from finished!","title":"\u26a1\ufe0f Circuit"},{"location":"#overview","text":"Circuit is a simple, lightweight, and extensible framework for building Kotlin applications that\u2019s Compose from the ground up. Compose Runtime vs. Compose UI Compose itself is essentially two libraries \u2013 Compose Compiler and Compose UI. Most folks usually think of Compose UI, but the compiler (and associated runtime) are actually not specific to UI at all and offer powerful state management APIs. Jake Wharton has an excellent post about this: https://jakewharton.com/a-jetpack-compose-by-any-other-name/ It builds upon core principles we already know like Presenters and UDF, and adds native support in its framework for all the other requirements we set out for above. It\u2019s heavily influenced by Cash App\u2019s Broadway architecture ( talked about at Droidcon NYC , also very derived from our conversations with them). Circuit\u2019s core components are its Presenter and Ui interfaces. A Presenter and a Ui cannot directly access each other. They can only communicate through state and event emissions. UIs are compose-first. Presenters are also compose-first. They do not emit Compose UI, but they do use the Compose runtime to manage and emit state. Both Presenter and Ui each have a single composable function. In most cases, Circuit automatically connects presenters and UIs. Presenter and Ui are both generic types, with generics to define the UiState types they communicate with. They are keyed by Screen s. One runs a new Presenter / Ui pairing by requesting them with a given Screen that they understand. Circuits The pairing of a Presenter and Ui for a given Screen key is what we semantically call a \u201ccircuit\u201d. Your application is composed of \u201ccircuits\u201d. A simple counter Presenter + Ui pairing would be a \u201ccounter circuit\u201d. Nested presenter/UIs would be \u201cnested circuits\u201d or \u201csub circuits\u201d Composite presenter/UIs would be \u201ccomposite circuits\u201d etc etc. Circuit\u2019s repo ( https://github.com/slackhq/circuit ) is being actively developed in the open, which allows us to continue collaborating with external folks too. We have a trivial-but-not-too-trivial sample app that we have been developing in it to serve as a demo for a number of common patterns in Circuit use.","title":"Overview"},{"location":"#counter-example","text":"This is a very simple case of a Counter circuit that displays the count and has buttons to increment and decrement. There\u2019s some glue code missing from this example that\u2019s covered in the Code Gen (TODO link) section later. @Parcelize object CounterScreen : Screen { data class CounterState ( val count : Int , val eventSink : ( CounterEvent ) -> Unit , ) : CircuitUiState sealed interface CounterEvent : CircuitUiEvent { object Increment : CounterEvent object Decrement : CounterEvent } } @CircuitInject < CounterScreen > @Composable fun CounterPresenter (): CounterState { var count by rememberSaveable { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } @CircuitInject < CounterScreen > @Composable fun Counter ( state : CounterState ) { Box ( Modifier . fillMaxSize ()) { Column ( Modifier . align ( Alignment . Center )) { Text ( modifier = Modifier . align ( CenterHorizontally ), text = \"Count: ${ state . count } \" , style = MaterialTheme . typography . displayLarge ) Spacer ( modifier = Modifier . height ( 16. dp )) val eventSink = state . eventSink Button ( modifier = Modifier . align ( CenterHorizontally ), onClick = { eventSink ( CounterEvent . Increment ) } ) { Icon ( rememberVectorPainter ( Icons . Filled . Add ), \"Increment\" ) } Button ( modifier = Modifier . align ( CenterHorizontally ), onClick = { eventSink ( CounterEvent . Decrement ) } ) { Icon ( rememberVectorPainter ( Icons . Filled . Remove ), \"Decrement\" ) } } } }","title":"Counter Example"},{"location":"#license","text":"Copyright 2022 Slack Technologies, LLC Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"circuit-content/","text":"CircuitContent \u00b6 The simplest entry point of a circuit is the composable CircuitContent function. This function accepts a Screen and automatically finds and pairs corresponding Presenter and Ui instances to render in it. setContent { CircuitContent ( HomeScreen ) }","title":"CircuitContent"},{"location":"circuit-content/#circuitcontent","text":"The simplest entry point of a circuit is the composable CircuitContent function. This function accepts a Screen and automatically finds and pairs corresponding Presenter and Ui instances to render in it. setContent { CircuitContent ( HomeScreen ) }","title":"CircuitContent"},{"location":"code-gen/","text":"Code Generation \u00b6 We plan to include code gen tools to cover most of any boilerplate, making the common paths simple while allowing for more complex hand-written structures when needed. At a high level using the examples above, we want to generate the following bits of code for users class FavoritesScreenUiFactory class FavoritesScreenPresenterFactory private fun favoritesUi () We\u2019re intentionally saving implementing this step last as it makes making API changes more difficult. Follow along progress here: https://github.com/slackhq/circuit/issues/13","title":"Code Generation"},{"location":"code-gen/#code-generation","text":"We plan to include code gen tools to cover most of any boilerplate, making the common paths simple while allowing for more complex hand-written structures when needed. At a high level using the examples above, we want to generate the following bits of code for users class FavoritesScreenUiFactory class FavoritesScreenPresenterFactory private fun favoritesUi () We\u2019re intentionally saving implementing this step last as it makes making API changes more difficult. Follow along progress here: https://github.com/slackhq/circuit/issues/13","title":"Code Generation"},{"location":"code-of-conduct/","text":"Code of Conduct \u00b6 Introduction \u00b6 Diversity and inclusion make our community strong. We encourage participation from the most varied and diverse backgrounds possible and want to be very clear about where we stand. Our goal is to maintain a safe, helpful and friendly community for everyone, regardless of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other defining characteristic. This code and related procedures also apply to unacceptable behavior occurring outside the scope of community activities, in all community venues (online and in-person) as well as in all one-on-one communications, and anywhere such behavior has the potential to adversely affect the safety and well-being of community members. For more information on our code of conduct, please visit https://slackhq.github.io/code-of-conduct","title":"CoC"},{"location":"code-of-conduct/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"code-of-conduct/#introduction","text":"Diversity and inclusion make our community strong. We encourage participation from the most varied and diverse backgrounds possible and want to be very clear about where we stand. Our goal is to maintain a safe, helpful and friendly community for everyone, regardless of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other defining characteristic. This code and related procedures also apply to unacceptable behavior occurring outside the scope of community activities, in all community venues (online and in-person) as well as in all one-on-one communications, and anywhere such behavior has the potential to adversely affect the safety and well-being of community members. For more information on our code of conduct, please visit https://slackhq.github.io/code-of-conduct","title":"Introduction"},{"location":"contributing/","text":"Contributors Guide \u00b6 Note that this project is considered READ-ONLY. You are welcome to discuss or ask questions in the discussions section of the repo, but we do not normally accept external contributions without prior discussion. Development \u00b6 Check out this repo with Android Studio. It\u2019s a standard gradle project and conventional to checkout. The primary project is circuit . The primary sample is sample . This project is written in Kotlin and should only use Kotlin. Code formatting is checked via Spotless . To run the formatter, use the spotlessApply command. ./gradlew spotlessApply","title":"Contributing"},{"location":"contributing/#contributors-guide","text":"Note that this project is considered READ-ONLY. You are welcome to discuss or ask questions in the discussions section of the repo, but we do not normally accept external contributions without prior discussion.","title":"Contributors Guide"},{"location":"contributing/#development","text":"Check out this repo with Android Studio. It\u2019s a standard gradle project and conventional to checkout. The primary project is circuit . The primary sample is sample . This project is written in Kotlin and should only use Kotlin. Code formatting is checked via Spotless . To run the formatter, use the spotlessApply command. ./gradlew spotlessApply","title":"Development"},{"location":"factories/","text":"Factories \u00b6 At its core, Circuit works on the Factory pattern. Every Presenter and Ui is contributed to a CircuitConfig instance by a corresponding factory that creates them for given Screen s. These are intended to be aggregated in the DI layer and added to a CircuitConfig instance during construction. val circuitConfig = CircuitConfig . Builder () . addUiFactory ( FavoritesUiFactory ()) . addPresenterFactory ( FavoritesPresenterFactory ()) . build () Look familiar? If you\u2019ve used Moshi or Retrofit, these should feel fairly familiar! Presenter factories can be generated or hand-written, depending on if they aggregate an entire screen or are simple one-offs. Presenters are also given access to the current Navigator in this level. class FavoritesScreenPresenterFactory @Inject constructor ( private val favoritesPresenterFactory : FavoritesPresenter . Factory , ) : Presenter . Factory { override fun create ( screen : Screen , navigator : Navigator ): Presenter <*>? { return when ( screen ) { is FavoritesScreen -> favoritesPresenterFactory . create ( screen , navigator ) else -> null } } } UI factories are similar, but generally should not aggregate other UIs unless there\u2019s a DI-specific reason to do so (which there usually isn\u2019t!). class FavoritesScreenUiFactory : @Inject constructor () : Ui . Factory { override fun create ( screen : Screen ): ScreenUi? { return when ( screen ) { is FavoritesScreen -> ScreenUi ( favoritesUi ()) else null -> } } } private fun favoritesUi () = ui < State > { state -> Favorites ( state ) } Info Note how these return a ScreenUi class that holds the Ui instance. We are using this indirection as a toe-hold for possible other future UI metadata, such as Modifier instances. We canonically write these out as a separate function ( favoritesUi() ) that returns a Ui , which in turn calls through to the real (basic) Compose UI function ( Favorites() ). This ensures our basic compose functions are top-level and accessible by tests, and also discourages storing anything in class members rather than idiomatic composable state vars.","title":"Factories"},{"location":"factories/#factories","text":"At its core, Circuit works on the Factory pattern. Every Presenter and Ui is contributed to a CircuitConfig instance by a corresponding factory that creates them for given Screen s. These are intended to be aggregated in the DI layer and added to a CircuitConfig instance during construction. val circuitConfig = CircuitConfig . Builder () . addUiFactory ( FavoritesUiFactory ()) . addPresenterFactory ( FavoritesPresenterFactory ()) . build () Look familiar? If you\u2019ve used Moshi or Retrofit, these should feel fairly familiar! Presenter factories can be generated or hand-written, depending on if they aggregate an entire screen or are simple one-offs. Presenters are also given access to the current Navigator in this level. class FavoritesScreenPresenterFactory @Inject constructor ( private val favoritesPresenterFactory : FavoritesPresenter . Factory , ) : Presenter . Factory { override fun create ( screen : Screen , navigator : Navigator ): Presenter <*>? { return when ( screen ) { is FavoritesScreen -> favoritesPresenterFactory . create ( screen , navigator ) else -> null } } } UI factories are similar, but generally should not aggregate other UIs unless there\u2019s a DI-specific reason to do so (which there usually isn\u2019t!). class FavoritesScreenUiFactory : @Inject constructor () : Ui . Factory { override fun create ( screen : Screen ): ScreenUi? { return when ( screen ) { is FavoritesScreen -> ScreenUi ( favoritesUi ()) else null -> } } } private fun favoritesUi () = ui < State > { state -> Favorites ( state ) } Info Note how these return a ScreenUi class that holds the Ui instance. We are using this indirection as a toe-hold for possible other future UI metadata, such as Modifier instances. We canonically write these out as a separate function ( favoritesUi() ) that returns a Ui , which in turn calls through to the real (basic) Compose UI function ( Favorites() ). This ensures our basic compose functions are top-level and accessible by tests, and also discourages storing anything in class members rather than idiomatic composable state vars.","title":"Factories"},{"location":"interop/","text":"Interop \u00b6 TODO: https://github.com/slackhq/circuit/issues/42","title":"Interop"},{"location":"interop/#interop","text":"TODO: https://github.com/slackhq/circuit/issues/42","title":"Interop"},{"location":"navigation/","text":"Navigation \u00b6 For navigable contents, we have a custom compose-based backstack implementation that the androidx folks shared with us. Navigation becomes two parts: A BackStack , where we use a SaveableBackStack implementation that saves a stack of Screen s and the ProvidedValues for each record on that stack (allowing us to save and restore on configuration changes automatically). A Navigator , which is a simple interface that we can point at a BackStack and offers simple goTo(<screen>) / pop() semantics. These are offered to presenters to perform navigation as needed to other screens. A new navigable content surface is handled via the NavigableCircuitContent functions. setContent { val backstack = rememberSaveableBackStack { push ( HomeScreen ) } val navigator = rememberCircuitNavigator ( backstack , onBackPressedDispatcher :: onBackPressed ) NavigableCircuitContent ( navigator , backstack ) } Presenters are then given access to these navigator instances via Presenter.Factory (described in TODO link Factories), which they can save if needed to perform navigation. fun showAddFavorites () { navigator . goTo ( AddFavorites ( externalId = uuidGenerator . generate () ) ) } Nested Navigation \u00b6 Navigation carries special semantic value in CircuitContent as well, where it\u2019s common for UIs to want to curry navigation events emitted by nested UIs. For this case, there\u2019s a CircuitContent overload that accepts an optional onNavEvent callback that you must then forward to a Navigator instance. @Composable fun ParentUi ( state : ParentState ) { CircuitContent ( NestedScreen , onNavEvent = { navEvent -> state . eventSink ( NestedNav ( navEvent )) }) } @Composable fun ParentPresenter ( navigator : Navigator ): ParentState { return ParentState (...) { event -> when ( event ) { is NestedNav -> navigator . onNavEvent ( event . navEvent ) } } } @Composable fun NestedPresenter ( navigator : Navigator ): NestedState { // These are forwarded up! navigator . goTo ( AnotherScreen ) // ... }","title":"Navigation"},{"location":"navigation/#navigation","text":"For navigable contents, we have a custom compose-based backstack implementation that the androidx folks shared with us. Navigation becomes two parts: A BackStack , where we use a SaveableBackStack implementation that saves a stack of Screen s and the ProvidedValues for each record on that stack (allowing us to save and restore on configuration changes automatically). A Navigator , which is a simple interface that we can point at a BackStack and offers simple goTo(<screen>) / pop() semantics. These are offered to presenters to perform navigation as needed to other screens. A new navigable content surface is handled via the NavigableCircuitContent functions. setContent { val backstack = rememberSaveableBackStack { push ( HomeScreen ) } val navigator = rememberCircuitNavigator ( backstack , onBackPressedDispatcher :: onBackPressed ) NavigableCircuitContent ( navigator , backstack ) } Presenters are then given access to these navigator instances via Presenter.Factory (described in TODO link Factories), which they can save if needed to perform navigation. fun showAddFavorites () { navigator . goTo ( AddFavorites ( externalId = uuidGenerator . generate () ) ) }","title":"Navigation"},{"location":"navigation/#nested-navigation","text":"Navigation carries special semantic value in CircuitContent as well, where it\u2019s common for UIs to want to curry navigation events emitted by nested UIs. For this case, there\u2019s a CircuitContent overload that accepts an optional onNavEvent callback that you must then forward to a Navigator instance. @Composable fun ParentUi ( state : ParentState ) { CircuitContent ( NestedScreen , onNavEvent = { navEvent -> state . eventSink ( NestedNav ( navEvent )) }) } @Composable fun ParentPresenter ( navigator : Navigator ): ParentState { return ParentState (...) { event -> when ( event ) { is NestedNav -> navigator . onNavEvent ( event . navEvent ) } } } @Composable fun NestedPresenter ( navigator : Navigator ): NestedState { // These are forwarded up! navigator . goTo ( AnotherScreen ) // ... }","title":"Nested Navigation"},{"location":"presenter/","text":"Presenter \u00b6 The core Presenter interface is this: interface Presenter < UiState : CircuitUiState > { @Composable fun present (): UiState } Presenters are solely intended to be business logic for your UI and a translation layer in front of your data layers. They are generally Dagger-injected types as the data layers they interpret are usually coming from the DI graph. In simple cases, they can be typed as a simple @Composable presenter function and Circuit code gen (TODO link) can generate the corresponding interface and (TODO link) factory for you. A very simple presenter can look like this: class FavoritesPresenter (...) : Presenter < State > { @Composable override fun present (): State { var favorites by remember { mutableStateOf ( < initial > ) } return State ( favorites ) { event -> ... } } } In this example, the present() function simply computes a state and returns it. If it has UI events to handle, an eventSink: (Event) -> Unit property should be exposed in the State type it returns. With DI, the above example becomes something more like this: class FavoritesPresenter @AssistedInject constructor ( @Assisted private val screen : FavoritesScreen , @Assisted private val navigator : Navigator , private val favoritesRepository : FavoritesRepository ) : Presenter < State > { @Composable override fun present (): State { // ... } @AssistedFactory fun interface Factory { fun create ( screen : FavoritesScreen , navigator : Navigator ): FavoritesPresenter } } Assisted injection allows passing on the screen and navigator from the relevant Presenter.Factory to this presenter for further reference. When dealing with nested presenters, a presenter could bypass implementing a class entirely by simply being written as a function that other presenters can use. // From cashapp/molecule's README examples @Composable fun ProfilePresenter ( userFlow : Flow < User > , balanceFlow : Flow < Long > , ): ProfileModel { val user by userFlow . collectAsState ( null ) val balance by balanceFlow . collectAsState ( 0L ) return if ( user == null ) { Loading } else { Data ( user . name , balance ) } } Presenters can present other presenters by injecting their assisted factories/providers, but note that this makes them a composite presenter that is now assuming responsibility for managing state of multiple nested presenters. We have an example of this in the Circuit repo . Retention \u00b6 There are three types of composable retention functions used in Circuit. remember \u2013 from Compose, remembers a value across recompositions. Can be any type. rememberRetained \u2013 custom, remembers a value across recompositions and configuration changes. Can be any type, but should not retain leak-able things like Navigator instances or Context instances. Backed by a hidden ViewModel on Android. rememberSaveable \u2013 from Compose, remembers a value across recompositions, configuration changes, and process death. Must be Parcelable or implement a custom Saver , should not retain leakable things like Navigator instances or Context instances. Backed by the framework saved instance state system. Developers should use the right tool accordingly depending on their use case. Consider these three examples. The first one will preserve the count value across recompositions, but not configuration changes or process death. @Composable fun CounterPresenter (): CounterState { var count by remember { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } The second one will preserve the state across recompositions and configuration changes, but not process death. @Composable fun CounterPresenter (): CounterState { var count by rememberRetained { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } The third case will preserve the count state across recompositions, configuration changes, and process death. However, it only works with primitives or Parcelable state types. @Composable fun CounterPresenter (): CounterState { var count by rememberSaveable { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } }","title":"Presenter"},{"location":"presenter/#presenter","text":"The core Presenter interface is this: interface Presenter < UiState : CircuitUiState > { @Composable fun present (): UiState } Presenters are solely intended to be business logic for your UI and a translation layer in front of your data layers. They are generally Dagger-injected types as the data layers they interpret are usually coming from the DI graph. In simple cases, they can be typed as a simple @Composable presenter function and Circuit code gen (TODO link) can generate the corresponding interface and (TODO link) factory for you. A very simple presenter can look like this: class FavoritesPresenter (...) : Presenter < State > { @Composable override fun present (): State { var favorites by remember { mutableStateOf ( < initial > ) } return State ( favorites ) { event -> ... } } } In this example, the present() function simply computes a state and returns it. If it has UI events to handle, an eventSink: (Event) -> Unit property should be exposed in the State type it returns. With DI, the above example becomes something more like this: class FavoritesPresenter @AssistedInject constructor ( @Assisted private val screen : FavoritesScreen , @Assisted private val navigator : Navigator , private val favoritesRepository : FavoritesRepository ) : Presenter < State > { @Composable override fun present (): State { // ... } @AssistedFactory fun interface Factory { fun create ( screen : FavoritesScreen , navigator : Navigator ): FavoritesPresenter } } Assisted injection allows passing on the screen and navigator from the relevant Presenter.Factory to this presenter for further reference. When dealing with nested presenters, a presenter could bypass implementing a class entirely by simply being written as a function that other presenters can use. // From cashapp/molecule's README examples @Composable fun ProfilePresenter ( userFlow : Flow < User > , balanceFlow : Flow < Long > , ): ProfileModel { val user by userFlow . collectAsState ( null ) val balance by balanceFlow . collectAsState ( 0L ) return if ( user == null ) { Loading } else { Data ( user . name , balance ) } } Presenters can present other presenters by injecting their assisted factories/providers, but note that this makes them a composite presenter that is now assuming responsibility for managing state of multiple nested presenters. We have an example of this in the Circuit repo .","title":"Presenter"},{"location":"presenter/#retention","text":"There are three types of composable retention functions used in Circuit. remember \u2013 from Compose, remembers a value across recompositions. Can be any type. rememberRetained \u2013 custom, remembers a value across recompositions and configuration changes. Can be any type, but should not retain leak-able things like Navigator instances or Context instances. Backed by a hidden ViewModel on Android. rememberSaveable \u2013 from Compose, remembers a value across recompositions, configuration changes, and process death. Must be Parcelable or implement a custom Saver , should not retain leakable things like Navigator instances or Context instances. Backed by the framework saved instance state system. Developers should use the right tool accordingly depending on their use case. Consider these three examples. The first one will preserve the count value across recompositions, but not configuration changes or process death. @Composable fun CounterPresenter (): CounterState { var count by remember { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } The second one will preserve the state across recompositions and configuration changes, but not process death. @Composable fun CounterPresenter (): CounterState { var count by rememberRetained { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } The third case will preserve the count state across recompositions, configuration changes, and process death. However, it only works with primitives or Parcelable state types. @Composable fun CounterPresenter (): CounterState { var count by rememberSaveable { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } }","title":"Retention"},{"location":"screen/","text":"Screen \u00b6 The core Screen interface is this: interface Screen : Parcelable These types are Parcelable for saveability in our backstack and easy deeplinking. A Screen can be a simple marker object type or a data object with information to pass on. @Parcelize data class AddFavorites ( val externalId : UUID ) : Screen These are used by Navigator s (when called from presenters) or CircuitContent (when called from UIs) to start a new sub-circuit. // In a presenter class fun showAddFavorites () { navigator . goTo ( AddFavorites ( externalId = uuidGenerator . generate () ) ) }","title":"Screen"},{"location":"screen/#screen","text":"The core Screen interface is this: interface Screen : Parcelable These types are Parcelable for saveability in our backstack and easy deeplinking. A Screen can be a simple marker object type or a data object with information to pass on. @Parcelize data class AddFavorites ( val externalId : UUID ) : Screen These are used by Navigator s (when called from presenters) or CircuitContent (when called from UIs) to start a new sub-circuit. // In a presenter class fun showAddFavorites () { navigator . goTo ( AddFavorites ( externalId = uuidGenerator . generate () ) ) }","title":"Screen"},{"location":"states-and-events/","text":"States and Events \u00b6 The core state and event interfaces in Circuit are CircuitUiState and CircuitUiEvent . All state and event types should implement/extend these marker interfaces. Presenters are simple functions that determine and return composable states. UIs are simple functions that render states. Uis can emit events via eventSink properties in state classes, which presenters then handle. These are the core building blocks! States and events should be immutable value types. Wait, event callbacks in state types? Yep! This may feel like a departure from how you\u2019ve written UDF patterns in the past, but we really like it. We tried different patterns before with event Flow s and having Circuit internals manage these for you, but we found they came with tradeoffs and friction points that we could avoid by just treating event emissions as another aspect of state. The end result is a tidier structure of state + event flows. Simpler cognitive overheads due to not always using Flow for events, which comes with caveats in compose (wrapping operators in remember calls, pipelining nested event flows, etc) Simple event-less UIs \u2013 state just doesn\u2019t have an event sink. Simpler testing \u2013 no manual event flow needed. You end up writing more realistic tests where you tick along your presenter by emitting with its returned states directly. Different state types can have different event handling (e.g. Click may not make sense for Loading states). No internal ceremony around setting up a Channel and multicasting event streams. No risk of dropping events (unlike Flow ). Note Currently, while functions are treated as implicitly Stable by the compose compiler, they not skippable when they\u2019re non-composable Unit-returning lambdas with equal-but-unstable captures. This may change though, and would be another free benefit for this case. A longer-form writeup can be found in this PR .","title":"States and Events"},{"location":"states-and-events/#states-and-events","text":"The core state and event interfaces in Circuit are CircuitUiState and CircuitUiEvent . All state and event types should implement/extend these marker interfaces. Presenters are simple functions that determine and return composable states. UIs are simple functions that render states. Uis can emit events via eventSink properties in state classes, which presenters then handle. These are the core building blocks! States and events should be immutable value types. Wait, event callbacks in state types? Yep! This may feel like a departure from how you\u2019ve written UDF patterns in the past, but we really like it. We tried different patterns before with event Flow s and having Circuit internals manage these for you, but we found they came with tradeoffs and friction points that we could avoid by just treating event emissions as another aspect of state. The end result is a tidier structure of state + event flows. Simpler cognitive overheads due to not always using Flow for events, which comes with caveats in compose (wrapping operators in remember calls, pipelining nested event flows, etc) Simple event-less UIs \u2013 state just doesn\u2019t have an event sink. Simpler testing \u2013 no manual event flow needed. You end up writing more realistic tests where you tick along your presenter by emitting with its returned states directly. Different state types can have different event handling (e.g. Click may not make sense for Loading states). No internal ceremony around setting up a Channel and multicasting event streams. No risk of dropping events (unlike Flow ). Note Currently, while functions are treated as implicitly Stable by the compose compiler, they not skippable when they\u2019re non-composable Unit-returning lambdas with equal-but-unstable captures. This may change though, and would be another free benefit for this case. A longer-form writeup can be found in this PR .","title":"States and Events"},{"location":"testing/","text":"Testing \u00b6 Circuit is designed to make testing as easy as possible. Its core components are not mockable nor do they need to be mocked. Fakes are provided where needed, everything else can be used directly. Circuit will have a test artifact containing APIs to aid testing both presenters and composable UIs: Presenter.test() - an extension function that bridges the Compose and coroutines world. Use of this function is recommended for testing presenter state emissions and incoming UI events. Under the hood it leverages Molecule and Turbine . FakeNavigator - a test fake implementing the Circuit/Navigator interface. Use of this object is recommended when testing screen navigation (ie. goTo, pop/back). Example \u00b6 Testing a Circuit Presenter and UI is a breeze! Consider the following example: data class Favorite ( id : Long , ...) @Parcelable object FavoritesScreen : Screen { sealed interface State : CircuitUiState { object Loading : State object NoFavorites : State data class Results ( val list : List < Favorite > , val eventSink : ( Event ) -> Unit ) : State } sealed interface Event : CircuitUiEvent { data class ClickFavorite ( id : Long ): Event } } class FavoritesPresenter @Inject constructor ( navigator : Navigator , repo : FavoritesRepository ) : Presenter < State > { @Composable override fun present (): State { val favorites by produceState < List < Favorites >?> ( null ) { value = repo . getFavorites () } return when { favorites == null -> Loading favorites . isEmpty () -> NoFavorites else -> Results ( favorites ) { event -> when ( event ) { is ClickFavorite -> navigator . goTo ( FavoriteScreen ( event . id )) } } } } } @Composable fun FavoritesList ( state : FavoritesScreen . State ) { when ( state ) { Loading -> Text ( text = stringResource ( R . string . loading_favorites )) NoFavorites -> Text ( modifier = Modifier . testTag ( \"no favorites\" ), text = stringResource ( R . string . no_favorites ) ) is Results -> { Text ( text = \"Your Favorites\" ) LazyColumn { items ( state . list ) { Favorite ( it , state . eventSink ) } } } } } @Composable private fun Favorite ( favorite : Favorite , eventSink : ( FavoritesScreen . Event ) -> Unit ) { Row ( modifier = Modifier . testTag ( \"favorite\" ), onClick = { eventSink ( ClickFavorite ( favorite . id )) } ) { Image ( drawable = favorite . drawable , contentDescription = stringResource ( R . string . favorite_image_desc ) ) Text ( text = favorite . name ) Text ( text = favorite . date ) } } Presenter Unit Tests \u00b6 Here\u2019s a test to verify presenter emissions using the Presenter.test() helper. This function acts as a shorthand over Molecule + Turbine to give you a ReceiveTurbine.() -> Unit lambda. @Test fun `present - emit loading state then list of favorites` () = runTest { val favorites = listOf ( Favorite ( 1L , ...)) val repo = TestFavoritesRepository ( favorites ) val presenter = PetListPresenter ( navigator , repo ) presenter . test { assertThat ( awaitItem ()). isEqualTo ( PetListScreen . State . Loading ) val resultsItem = awaitItem () as Results assertThat ( resultsItem . favorites ). isEqualTo ( favorites ) } } The same helper can be used when testing how the presenter responds to incoming events : @Test fun `present - navigate to favorite screen` () = runTest { val repo = TestFavoritesRepository ( Favorite ( 123L )) val presenter = PetListPresenter ( navigator , repo ) presenter . test { assertThat ( awaitItem ()). isEqualTo ( PetListScreen . State . Loading ) val resultsItem = awaitItem () as Results assertThat ( resultsItem . favorites ). isEqualTo ( favorites ) val clickFavorite = FavoriteScreen . Event . ClickFavorite ( 123L ) // simulate user tapping favorite in UI resultsItem . eventSink ( clickFavorite ) assertThat ( navigator . awaitNextScreen ()). isEqualTo ( FavoriteScreen ( clickFavorite . id )) } } Android UI Instrumentation Tests \u00b6 UI tests can be driven directly through ComposeTestRule and use its Espresso-esque API for assertions: @Test fun favoritesList_show_favorites_for_result_state () = runTest { val favorites = listOf ( Favorite ( 1L , ...) composeTestRule . run { setContent { // bootstrap the UI in the desired state FavoritesList ( state = FavoriteScreen . State . Results ( favorites ) { /* event callback */ } ) } onNodeWithTag ( \"no favorites\" ). assertDoesNotExist () onNodeWithText ( \"Your Favorites\" ). assertIsDisplayed () onAllNodesWithTag ( \"favorite\" ). assertCountEquals ( 1 ) } } Future: Android UI Unit Tests via Paparazzi \u00b6 We\u2019ve started exploring use of Paparazzi , which allows us to render Android UI without a physical device or emulator. More to come soon, but in short it would work similar to the above but be for purely non-functional 1:1 state \u2194 UI tests. @Test fun previewFavorite () { paparazzi . snapshot { PreviewFavorite () } } These are easy to maintain and review in GitHub. Another neat idea is we think this will make it easy to stand up compose preview functions for IDE use and reuse them. // In your main source @Preview @Composable internal fun PreviewFavorite () { Favorite () } // In your unit test @Test fun previewFavorite () { paparazzi . snapshot { PreviewFavorite () } }","title":"Testing"},{"location":"testing/#testing","text":"Circuit is designed to make testing as easy as possible. Its core components are not mockable nor do they need to be mocked. Fakes are provided where needed, everything else can be used directly. Circuit will have a test artifact containing APIs to aid testing both presenters and composable UIs: Presenter.test() - an extension function that bridges the Compose and coroutines world. Use of this function is recommended for testing presenter state emissions and incoming UI events. Under the hood it leverages Molecule and Turbine . FakeNavigator - a test fake implementing the Circuit/Navigator interface. Use of this object is recommended when testing screen navigation (ie. goTo, pop/back).","title":"Testing"},{"location":"testing/#example","text":"Testing a Circuit Presenter and UI is a breeze! Consider the following example: data class Favorite ( id : Long , ...) @Parcelable object FavoritesScreen : Screen { sealed interface State : CircuitUiState { object Loading : State object NoFavorites : State data class Results ( val list : List < Favorite > , val eventSink : ( Event ) -> Unit ) : State } sealed interface Event : CircuitUiEvent { data class ClickFavorite ( id : Long ): Event } } class FavoritesPresenter @Inject constructor ( navigator : Navigator , repo : FavoritesRepository ) : Presenter < State > { @Composable override fun present (): State { val favorites by produceState < List < Favorites >?> ( null ) { value = repo . getFavorites () } return when { favorites == null -> Loading favorites . isEmpty () -> NoFavorites else -> Results ( favorites ) { event -> when ( event ) { is ClickFavorite -> navigator . goTo ( FavoriteScreen ( event . id )) } } } } } @Composable fun FavoritesList ( state : FavoritesScreen . State ) { when ( state ) { Loading -> Text ( text = stringResource ( R . string . loading_favorites )) NoFavorites -> Text ( modifier = Modifier . testTag ( \"no favorites\" ), text = stringResource ( R . string . no_favorites ) ) is Results -> { Text ( text = \"Your Favorites\" ) LazyColumn { items ( state . list ) { Favorite ( it , state . eventSink ) } } } } } @Composable private fun Favorite ( favorite : Favorite , eventSink : ( FavoritesScreen . Event ) -> Unit ) { Row ( modifier = Modifier . testTag ( \"favorite\" ), onClick = { eventSink ( ClickFavorite ( favorite . id )) } ) { Image ( drawable = favorite . drawable , contentDescription = stringResource ( R . string . favorite_image_desc ) ) Text ( text = favorite . name ) Text ( text = favorite . date ) } }","title":"Example"},{"location":"testing/#presenter-unit-tests","text":"Here\u2019s a test to verify presenter emissions using the Presenter.test() helper. This function acts as a shorthand over Molecule + Turbine to give you a ReceiveTurbine.() -> Unit lambda. @Test fun `present - emit loading state then list of favorites` () = runTest { val favorites = listOf ( Favorite ( 1L , ...)) val repo = TestFavoritesRepository ( favorites ) val presenter = PetListPresenter ( navigator , repo ) presenter . test { assertThat ( awaitItem ()). isEqualTo ( PetListScreen . State . Loading ) val resultsItem = awaitItem () as Results assertThat ( resultsItem . favorites ). isEqualTo ( favorites ) } } The same helper can be used when testing how the presenter responds to incoming events : @Test fun `present - navigate to favorite screen` () = runTest { val repo = TestFavoritesRepository ( Favorite ( 123L )) val presenter = PetListPresenter ( navigator , repo ) presenter . test { assertThat ( awaitItem ()). isEqualTo ( PetListScreen . State . Loading ) val resultsItem = awaitItem () as Results assertThat ( resultsItem . favorites ). isEqualTo ( favorites ) val clickFavorite = FavoriteScreen . Event . ClickFavorite ( 123L ) // simulate user tapping favorite in UI resultsItem . eventSink ( clickFavorite ) assertThat ( navigator . awaitNextScreen ()). isEqualTo ( FavoriteScreen ( clickFavorite . id )) } }","title":"Presenter Unit Tests"},{"location":"testing/#android-ui-instrumentation-tests","text":"UI tests can be driven directly through ComposeTestRule and use its Espresso-esque API for assertions: @Test fun favoritesList_show_favorites_for_result_state () = runTest { val favorites = listOf ( Favorite ( 1L , ...) composeTestRule . run { setContent { // bootstrap the UI in the desired state FavoritesList ( state = FavoriteScreen . State . Results ( favorites ) { /* event callback */ } ) } onNodeWithTag ( \"no favorites\" ). assertDoesNotExist () onNodeWithText ( \"Your Favorites\" ). assertIsDisplayed () onAllNodesWithTag ( \"favorite\" ). assertCountEquals ( 1 ) } }","title":"Android UI Instrumentation Tests"},{"location":"testing/#future-android-ui-unit-tests-via-paparazzi","text":"We\u2019ve started exploring use of Paparazzi , which allows us to render Android UI without a physical device or emulator. More to come soon, but in short it would work similar to the above but be for purely non-functional 1:1 state \u2194 UI tests. @Test fun previewFavorite () { paparazzi . snapshot { PreviewFavorite () } } These are easy to maintain and review in GitHub. Another neat idea is we think this will make it easy to stand up compose preview functions for IDE use and reuse them. // In your main source @Preview @Composable internal fun PreviewFavorite () { Favorite () } // In your unit test @Test fun previewFavorite () { paparazzi . snapshot { PreviewFavorite () } }","title":"Future: Android UI Unit Tests via Paparazzi"},{"location":"ui/","text":"UI \u00b6 The core Ui interface is simply this: interface Ui < UiState : CircuitUiState > { @Composable fun Content ( state : UiState ) } Like presenters, simple UIs can also skip the class all together for use in other UIs. Core unit of granularity is just the @Composable function. In fact, when implementing these in practice they rarely use dependency injection at all and can normally just be written as top-level composable functions annotated with @CircuitInject . @CircuitInject < FavoritesScreen > // Relevant DI wiring is generated @Composable private fun Favorites ( state : FavoritesState ) { // ... } Writing UIs like this has a number of benefits. Functions-only nudges developers toward writing idiomatic compose code and not keeping un-scoped/un-observable state elsewhere (such as class properties). These functions are extremely easy to stand up in tests. These functions are extremely easy to stand up in Compose preview functions. Let\u2019s look a little more closely at the last bullet point about preview functions. With the above example, we can easily stand up previews for all of our different states! @Preview @Composable private fun PreviewFavorites () = Favorites ( FavoritesState ( listOf ( \"Reeses\" , \"Lola\" )) @Preview @Composable private fun PreviewEmptyFavorites () = Favorites ( FavoritesState ( listOf ()) TODO image sample of IDE preview","title":"Ui"},{"location":"ui/#ui","text":"The core Ui interface is simply this: interface Ui < UiState : CircuitUiState > { @Composable fun Content ( state : UiState ) } Like presenters, simple UIs can also skip the class all together for use in other UIs. Core unit of granularity is just the @Composable function. In fact, when implementing these in practice they rarely use dependency injection at all and can normally just be written as top-level composable functions annotated with @CircuitInject . @CircuitInject < FavoritesScreen > // Relevant DI wiring is generated @Composable private fun Favorites ( state : FavoritesState ) { // ... } Writing UIs like this has a number of benefits. Functions-only nudges developers toward writing idiomatic compose code and not keeping un-scoped/un-observable state elsewhere (such as class properties). These functions are extremely easy to stand up in tests. These functions are extremely easy to stand up in Compose preview functions. Let\u2019s look a little more closely at the last bullet point about preview functions. With the above example, we can easily stand up previews for all of our different states! @Preview @Composable private fun PreviewFavorites () = Favorites ( FavoritesState ( listOf ( \"Reeses\" , \"Lola\" )) @Preview @Composable private fun PreviewEmptyFavorites () = Favorites ( FavoritesState ( listOf ()) TODO image sample of IDE preview","title":"UI"}]}